{"ast":null,"code":"var Scope = /* @__PURE__ */(Scope2 => (Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2))(Scope || {});\nclass Attributor {\n  constructor(attrName, keyName, options = {}) {\n    this.attrName = attrName, this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ?\n    // Ignore type bits, force attribute bit\n    options.scope & Scope.LEVEL | attributeBit : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  static keys(node) {\n    return Array.from(node.attributes).map(item => item.name);\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n  }\n  canAdd(_node, value) {\n    return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n  }\n  remove(node) {\n    node.removeAttribute(this.keyName);\n  }\n  value(node) {\n    const value = node.getAttribute(this.keyName);\n    return this.canAdd(node, value) && value ? value : \"\";\n  }\n}\nclass ParchmentError extends Error {\n  constructor(message) {\n    message = \"[Parchment] \" + message, super(message), this.message = message, this.name = this.constructor.name;\n  }\n}\nconst _Registry = class _Registry {\n  constructor() {\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  static find(node, bubble = !1) {\n    if (node == null) return null;\n    if (this.blots.has(node)) return this.blots.get(node) || null;\n    if (bubble) {\n      let parentNode = null;\n      try {\n        parentNode = node.parentNode;\n      } catch {\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n  create(scroll, input, value) {\n    const match2 = this.query(input);\n    if (match2 == null) throw new ParchmentError(`Unable to create ${input} blot`);\n    const blotClass = match2,\n      node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value),\n      blot = new blotClass(scroll, node, value);\n    return _Registry.blots.set(blot.domNode, blot), blot;\n  }\n  find(node, bubble = !1) {\n    return _Registry.find(node, bubble);\n  }\n  query(query, scope = Scope.ANY) {\n    let match2;\n    return typeof query == \"string\" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == \"number\" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute(\"class\") || \"\").split(/\\s+/).some(name => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n  }\n  register(...definitions) {\n    return definitions.map(definition => {\n      const isBlot = (\"blotName\" in definition),\n        isAttr = (\"attrName\" in definition);\n      if (!isBlot && !isAttr) throw new ParchmentError(\"Invalid definition\");\n      if (isBlot && definition.blotName === \"abstract\") throw new ParchmentError(\"Cannot register abstract class\");\n      const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n      return this.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map(tagName => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach(tag => {\n        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);\n      }))), definition;\n    });\n  }\n};\n_Registry.blots = /* @__PURE__ */new WeakMap();\nlet Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter(name => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(name => name.split(\"-\").slice(0, -1).join(\"-\"));\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), !0) : !1;\n  }\n  remove(node) {\n    match(node, this.keyName).forEach(name => {\n      node.classList.remove(name);\n    }), node.classList.length === 0 && node.removeAttribute(\"class\");\n  }\n  value(node) {\n    const value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  const parts = name.split(\"-\"),\n    rest = parts.slice(1).map(part => part[0].toUpperCase() + part.slice(1)).join(\"\");\n  return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"style\") || \"\").split(\";\").map(value => value.split(\":\")[0].trim());\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n  }\n  remove(node) {\n    node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n  }\n  value(node) {\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst StyleAttributor$1 = StyleAttributor;\nclass AttributorStore {\n  constructor(domNode) {\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  attribute(attribute, value) {\n    value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);\n  }\n  build() {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) return;\n    const attributes = Attributor.keys(this.domNode),\n      classes = ClassAttributor$1.keys(this.domNode),\n      styles = StyleAttributor$1.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach(name => {\n      const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n      attr instanceof Attributor && (this.attributes[attr.attrName] = attr);\n    });\n  }\n  copy(target) {\n    Object.keys(this.attributes).forEach(key => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n  move(target) {\n    this.copy(target), Object.keys(this.attributes).forEach(key => {\n      this.attributes[key].remove(this.domNode);\n    }), this.attributes = {};\n  }\n  values() {\n    return Object.keys(this.attributes).reduce((attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes), {});\n  }\n}\nconst AttributorStore$1 = AttributorStore,\n  _ShadowBlot = class _ShadowBlot {\n    constructor(scroll, domNode) {\n      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n    }\n    static create(rawValue) {\n      if (this.tagName == null) throw new ParchmentError(\"Blot definition missing tagName\");\n      let node, value;\n      return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n      return this.constructor;\n    }\n    attach() {}\n    clone() {\n      const domNode = this.domNode.cloneNode(!1);\n      return this.scroll.create(domNode);\n    }\n    detach() {\n      this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.isolate(index, length).remove();\n    }\n    formatAt(index, length, name, value) {\n      const blot = this.isolate(index, length);\n      if (this.scroll.query(name, Scope.BLOT) != null && value) blot.wrap(name, value);else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n        const parent = this.scroll.create(this.statics.scope);\n        blot.wrap(parent), parent.format(name, value);\n      }\n    }\n    insertAt(index, value, def) {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def),\n        ref = this.split(index);\n      this.parent.insertBefore(blot, ref || void 0);\n    }\n    isolate(index, length) {\n      const target = this.split(index);\n      if (target == null) throw new Error(\"Attempt to isolate at end\");\n      return target.split(length), target;\n    }\n    length() {\n      return 1;\n    }\n    offset(root = this.parent) {\n      return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n      this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n    }\n    remove() {\n      this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n    }\n    replaceWith(name, value) {\n      const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n    }\n    split(index, _force) {\n      return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {}\n    wrap(name, value) {\n      const wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n      if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\") throw new ParchmentError(`Cannot wrap ${name}`);\n      return wrapper.appendChild(this), wrapper;\n    }\n  };\n_ShadowBlot.blotName = \"abstract\";\nlet ShadowBlot = _ShadowBlot;\nconst _LeafBlot = class _LeafBlot extends ShadowBlot {\n  /**\r\n   * Returns the value represented by domNode if it is this Blot's type\r\n   * No checking that domNode can represent this Blot type is required so\r\n   * applications needing it should check externally before calling.\r\n   */\n  static value(_domNode) {\n    return !0;\n  }\n  /**\r\n   * Given location represented by node and offset from DOM Selection Range,\r\n   * return index to that location.\r\n   */\n  index(node, offset) {\n    return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n  }\n  /**\r\n   * Given index to location within blot, return node and offset representing\r\n   * that location, consumable by DOM Selection Range\r\n   */\n  position(index, _inclusive) {\n    let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n    return index > 0 && (offset += 1), [this.parent.domNode, offset];\n  }\n  /**\r\n   * Return value represented by this blot\r\n   * Should not change without interaction from API or\r\n   * user change detectable by update()\r\n   */\n  value() {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || !0\n    };\n  }\n};\n_LeafBlot.scope = Scope.INLINE_BLOT;\nlet LeafBlot = _LeafBlot;\nconst LeafBlot$1 = LeafBlot;\nclass LinkedList {\n  constructor() {\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  append(...nodes) {\n    if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n  at(index) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur && index > 0;) index -= 1, cur = next();\n    return cur;\n  }\n  contains(node) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      if (cur === node) return !0;\n      cur = next();\n    }\n    return !1;\n  }\n  indexOf(node) {\n    const next = this.iterator();\n    let cur = next(),\n      index = 0;\n    for (; cur;) {\n      if (cur === node) return index;\n      index += 1, cur = next();\n    }\n    return -1;\n  }\n  insertBefore(node, refNode) {\n    node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n  }\n  offset(target) {\n    let index = 0,\n      cur = this.head;\n    for (; cur != null;) {\n      if (cur === target) return index;\n      index += cur.length(), cur = cur.next;\n    }\n    return -1;\n  }\n  remove(node) {\n    this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n  }\n  iterator(curNode = this.head) {\n    return () => {\n      const ret = curNode;\n      return curNode != null && (curNode = curNode.next), ret;\n    };\n  }\n  find(index, inclusive = !1) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) {\n      const length = cur.length();\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) return [cur, index];\n      index -= length, cur = next();\n    }\n    return [null, 0];\n  }\n  forEach(callback) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) callback(cur), cur = next();\n  }\n  forEachAt(index, length, callback) {\n    if (length <= 0) return;\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    for (; cur && curIndex < index + length;) {\n      const curLength = cur.length();\n      index > curIndex ? callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index)) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n    }\n  }\n  map(callback) {\n    return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);\n  }\n  reduce(callback, memo) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur;) memo = callback(memo, cur), cur = next();\n    return memo;\n  }\n}\nfunction makeAttachedBlot(node, scroll) {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch {\n    const blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach(child => {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nconst _ParentBlot = class _ParentBlot extends ShadowBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.uiNode = null, this.build();\n  }\n  appendChild(other) {\n    this.insertBefore(other);\n  }\n  attach() {\n    super.attach(), this.children.forEach(child => {\n      child.attach();\n    });\n  }\n  attachUI(node) {\n    this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n  /**\r\n   * Called during construction, should fill its own children LinkedList.\r\n   */\n  build() {\n    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter(node => node !== this.uiNode).reverse().forEach(node => {\n      try {\n        const child = makeAttachedBlot(node, this.scroll);\n        this.insertBefore(child, this.children.head || void 0);\n      } catch (err) {\n        if (err instanceof ParchmentError) return;\n        throw err;\n      }\n    });\n  }\n  deleteAt(index, length) {\n    if (index === 0 && length === this.length()) return this.remove();\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n  descendant(criteria, index = 0) {\n    const [child, offset] = this.children.find(index);\n    return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n  }\n  descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n    let descendants = [],\n      lengthLeft = length;\n    return this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n      (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft))), lengthLeft -= childLength;\n    }), descendants;\n  }\n  detach() {\n    this.children.forEach(child => {\n      child.detach();\n    }), super.detach();\n  }\n  enforceAllowedChildren() {\n    let done = !1;\n    this.children.forEach(child => {\n      done || this.statics.allowedChildren.some(def => child instanceof def) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n    });\n  }\n  formatAt(index, length, name, value) {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n  insertAt(index, value, def) {\n    const [child, offset] = this.children.find(index);\n    if (child) child.insertAt(offset, value, def);else {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n  insertBefore(childBlot, refBlot) {\n    childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n    let refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n  }\n  length() {\n    return this.children.reduce((memo, child) => memo + child.length(), 0);\n  }\n  moveChildren(targetParent, refNode) {\n    this.children.forEach(child => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n  optimize(context) {\n    if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0) if (this.statics.defaultChild != null) {\n      const child = this.scroll.create(this.statics.defaultChild.blotName);\n      this.appendChild(child);\n    } else this.remove();\n  }\n  path(index, inclusive = !1) {\n    const [child, offset] = this.children.find(index, inclusive),\n      position = [[this, index]];\n    return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n  }\n  removeChild(child) {\n    this.children.remove(child);\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0) return this;\n      if (index === this.length()) return this.next;\n    }\n    const after = this.clone();\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      split != null && after.appendChild(split);\n    }), after;\n  }\n  splitAfter(child) {\n    const after = this.clone();\n    for (; child.next != null;) after.appendChild(child.next);\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n  }\n  unwrap() {\n    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n  }\n  update(mutations, _context) {\n    const addedNodes = [],\n      removedNodes = [];\n    mutations.forEach(mutation => {\n      mutation.target === this.domNode && mutation.type === \"childList\" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));\n    }), removedNodes.forEach(node => {\n      if (node.parentNode != null &&\n      // @ts-expect-error Fix me later\n      node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) return;\n      const blot = this.scroll.find(node);\n      blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();\n    }), addedNodes.filter(node => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach(node => {\n      let refBlot = null;\n      node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));\n      const blot = makeAttachedBlot(node, this.scroll);\n      (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));\n    }), this.enforceAllowedChildren();\n  }\n};\n_ParentBlot.uiClass = \"\";\nlet ParentBlot = _ParentBlot;\nconst ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) return !1;\n  for (const prop in obj1) if (obj1[prop] !== obj2[prop]) return !1;\n  return !0;\n}\nconst _InlineBlot = class _InlineBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_InlineBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\") return !0;\n      if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    if (name === this.statics.blotName && !value) this.children.forEach(child => {\n      child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), this.attributes.copy(child);\n    }), this.unwrap();else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) return;\n      format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n    }\n  }\n  formats() {\n    const formats = this.attributes.values(),\n      format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);\n  }\n  optimize(context) {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) return this.unwrap();\n    const next = this.next;\n    next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n  }\n  wrap(name, value) {\n    const wrapper = super.wrap(name, value);\n    return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n  }\n};\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nlet InlineBlot = _InlineBlot;\nconst InlineBlot$1 = InlineBlot,\n  _BlockBlot = class _BlockBlot extends ParentBlot$1 {\n    static create(value) {\n      return super.create(value);\n    }\n    static formats(domNode, scroll) {\n      const match2 = scroll.query(_BlockBlot.blotName);\n      if (!(match2 != null && domNode.tagName === match2.tagName)) {\n        if (typeof this.tagName == \"string\") return !0;\n        if (Array.isArray(this.tagName)) return domNode.tagName.toLowerCase();\n      }\n    }\n    constructor(scroll, domNode) {\n      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n    }\n    format(name, value) {\n      const format = this.scroll.query(name, Scope.BLOCK);\n      format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n    }\n    formats() {\n      const formats = this.attributes.values(),\n        format = this.statics.formats(this.domNode, this.scroll);\n      return format != null && (formats[this.statics.blotName] = format), formats;\n    }\n    formatAt(index, length, name, value) {\n      this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      if (def == null || this.scroll.query(value, Scope.INLINE) != null) super.insertAt(index, value, def);else {\n        const after = this.split(index);\n        if (after != null) {\n          const blot = this.scroll.create(value, def);\n          after.parent.insertBefore(blot, after);\n        } else throw new Error(\"Attempt to insertAt after block boundaries\");\n      }\n    }\n    replaceWith(name, value) {\n      const replacement = super.replaceWith(name, value);\n      return this.attributes.copy(replacement), replacement;\n    }\n    update(mutations, context) {\n      super.update(mutations, context), mutations.some(mutation => mutation.target === this.domNode && mutation.type === \"attributes\") && this.attributes.build();\n    }\n  };\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [InlineBlot$1, _BlockBlot, LeafBlot$1];\nlet BlockBlot = _BlockBlot;\nconst BlockBlot$1 = BlockBlot,\n  _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {\n    checkMerge() {\n      return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n    }\n    deleteAt(index, length) {\n      super.deleteAt(index, length), this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n      super.formatAt(index, length, name, value), this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n      super.insertAt(index, value, def), this.enforceAllowedChildren();\n    }\n    optimize(context) {\n      super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n    }\n  };\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nlet ContainerBlot = _ContainerBlot;\nconst ContainerBlot$1 = ContainerBlot;\nclass EmbedBlot extends LeafBlot$1 {\n  static formats(_domNode, _scroll) {}\n  format(name, value) {\n    super.formatAt(0, this.length(), name, value);\n  }\n  formatAt(index, length, name, value) {\n    index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  formats() {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\nconst EmbedBlot$1 = EmbedBlot,\n  OBSERVER_CONFIG = {\n    attributes: !0,\n    characterData: !0,\n    characterDataOldValue: !0,\n    childList: !0,\n    subtree: !0\n  },\n  MAX_OPTIMIZE_ITERATIONS = 100,\n  _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {\n    constructor(registry, node) {\n      super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver(mutations => {\n        this.update(mutations);\n      }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();\n    }\n    create(input, value) {\n      return this.registry.create(this, input, value);\n    }\n    find(node, bubble = !1) {\n      const blot = this.registry.find(node, bubble);\n      return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n    }\n    query(query, scope = Scope.ANY) {\n      return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n      return this.registry.register(...definitions);\n    }\n    build() {\n      this.scroll != null && super.build();\n    }\n    detach() {\n      super.detach(), this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n      this.update(), index === 0 && length === this.length() ? this.children.forEach(child => {\n        child.remove();\n      }) : super.deleteAt(index, length);\n    }\n    formatAt(index, length, name, value) {\n      this.update(), super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n      this.update(), super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n      super.optimize(context);\n      const mutationsMap = context.mutationsMap || /* @__PURE__ */new WeakMap();\n      let records = Array.from(this.observer.takeRecords());\n      for (; records.length > 0;) mutations.push(records.pop());\n      const mark = (blot, markParent = !0) => {\n          blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));\n        },\n        optimize = blot => {\n          mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));\n        };\n      let remaining = mutations;\n      for (let i = 0; remaining.length > 0; i += 1) {\n        if (i >= MAX_OPTIMIZE_ITERATIONS) throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        for (remaining.forEach(mutation => {\n          const blot = this.find(mutation.target, !0);\n          blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (mark(this.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach(node => {\n            const child = this.find(node, !1);\n            mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach(grandChild => {\n              mark(grandChild, !1);\n            });\n          })) : mutation.type === \"attributes\" && mark(blot.prev)), mark(blot));\n        }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0;) mutations.push(records.pop());\n      }\n    }\n    update(mutations, context = {}) {\n      mutations = mutations || this.observer.takeRecords();\n      const mutationsMap = /* @__PURE__ */new WeakMap();\n      mutations.map(mutation => {\n        const blot = this.find(mutation.target, !0);\n        return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n      }).forEach(blot => {\n        blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n      }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);\n    }\n  };\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nlet ScrollBlot = _ScrollBlot;\nconst ScrollBlot$1 = ScrollBlot,\n  _TextBlot = class _TextBlot extends LeafBlot$1 {\n    static create(value) {\n      return document.createTextNode(value);\n    }\n    static value(domNode) {\n      return domNode.data;\n    }\n    constructor(scroll, node) {\n      super(scroll, node), this.text = this.statics.value(this.domNode);\n    }\n    deleteAt(index, length) {\n      this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n      return this.domNode === node ? offset : -1;\n    }\n    insertAt(index, value, def) {\n      def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);\n    }\n    length() {\n      return this.text.length;\n    }\n    optimize(context) {\n      super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n    }\n    position(index, _inclusive = !1) {\n      return [this.domNode, index];\n    }\n    split(index, force = !1) {\n      if (!force) {\n        if (index === 0) return this;\n        if (index === this.length()) return this.next;\n      }\n      const after = this.scroll.create(this.domNode.splitText(index));\n      return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n    }\n    update(mutations, _context) {\n      mutations.some(mutation => mutation.type === \"characterData\" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));\n    }\n    value() {\n      return this.text;\n    }\n  };\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nlet TextBlot = _TextBlot;\nconst TextBlot$1 = TextBlot;\nexport { Attributor, AttributorStore$1 as AttributorStore, BlockBlot$1 as BlockBlot, ClassAttributor$1 as ClassAttributor, ContainerBlot$1 as ContainerBlot, EmbedBlot$1 as EmbedBlot, InlineBlot$1 as InlineBlot, LeafBlot$1 as LeafBlot, ParentBlot$1 as ParentBlot, Registry, Scope, ScrollBlot$1 as ScrollBlot, StyleAttributor$1 as StyleAttributor, TextBlot$1 as TextBlot };\n//# sourceMappingURL=parchment.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}